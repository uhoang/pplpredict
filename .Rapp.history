nrow(W2)
dim(W2)
names(W2)
t(questions)
nrow(Weighted)
library(pplpredict)
data(Queensland)
head(Queensland)
?vplTable
?peoplePrediction
rm(list = ls())
remove.packages("pplpredict")
installed.packages()
library(devtools)
devtools::install_github("uyenhoang/pplpredict")
data(Queensland)
head(Queensland)
peoplePrediction(Queensland, paste0("party", 1:4,"B"), c("Labor", "Greens","LibNat","Katter"))
library(pplpredict)
data(Queensland)
head(Queensland)
pplpredict(Queensland, paste0("party",1:4, "B"), c("Labor","Greens","LibNat","Katter"))
peoplePrediction(Queensland, paste0("party",1:4, "B"), c("Labor","Greens","LibNat","Katter"))
?peoplePredcition
?peoplePrediction
?maxWrapper
??maxWrapper
?pplpredict
??pplpredict
?RCIMeasure
??RCIMeasure
?maxWrapper
??maxWrapper
library(pplpredict)
?maxWrapper
?rescaleWrapper
?peoplePrediction
library(survey)#
library(ggplot2)#
library(gridExtra) # for unit()#
library(reshape) # for melt()#
library(plyr)#
library(parallel)#
# library(multicore)#
options(java.parameters = "-Xmx16g") # Set the java heap size to 16gb (RAM). Load before xlsx library.#
library(xlsx)#
library(Zelig)#
library(Amelia)#
library(chron)#
library(blme) # MRP#
library(lme4) # MRP#
library(arm) # MRP#
library(extrafont) # Update fonts with font_import()#
library(data.table)#
##### BASIC THEME#
#
my.theme <- function(base_size = 11, base_family = "",#
                     grid.x_colour = NA, grid.y_colour = NA,#
                     grid.x_linetype = 1, grid.y_linetype = 1,#
                     strip_colour = "grey15", strip_text = "black",#
                     background_colour = "transparent",#
                     tick_colour = "black",#
                     borderless = 0, bordersize = 0.5){ #
  if(is.na(grid.x_colour)) grid.x_colour <- "transparent"#
  if(is.na(grid.y_colour)) grid.y_colour <- "transparent"#
  if(borderless == 2){#
    border <- theme(#axis.line = element_line(colour = "black", size = 0.25`),#
                    panel.border = element_blank(),#
                    panel.background = element_blank(),#
                    strip.background = element_blank())#
  }#
#
  else if(borderless == 1){#
    border <- theme(axis.line = element_line(colour = "black", size = 0.25),#
                    panel.border = element_blank(),#
                    panel.background = element_blank(),#
                    strip.background = element_blank())#
  }#
  else if(borderless == 0) border <- theme()#
    theme( #
      axis.text.x       = element_text(family = base_family, colour = "grey15", size = base_size, vjust = 1, lineheight = 0.9),#
      axis.text.y       = element_text(family = base_family, colour = "grey15", size = base_size, hjust = 1, lineheight = 0.9),#
      axis.ticks        = element_line(colour = tick_colour, size = 0.2),#
      axis.ticks.length = unit(0.25, "lines"),#
      axis.ticks.margin = unit(0.15, "cm"),#
      axis.title.x      = element_text(family = base_family, size = base_size, colour = "black", vjust = -0.5),#
      axis.title.y      = element_text(family = base_family, size = base_size, angle = 90, colour = "black", vjust = 0.25),#
      legend.background = element_rect(colour = "grey15", fill = "transparent", size = 0.25),#
      legend.key = element_blank(), #element_rect(colour = "transparent", fill = "transparent") #
      legend.key.size = unit(0.6, "lines"),#
      legend.text = element_text(family = base_family, size = base_size, face = "italic", lineheight = 1),#
      legend.text.align = 0, #
      legend.title = element_text(family = base_family, size = base_size, face = "plain", hjust = 0),#
      legend.title.align = 0,#
      legend.position = "top",#
      legend.direction = "horizontal",#
      legend.justification = c(1, 1),#
      panel.background = element_rect(fill = "transparent", colour = "black", size = 0.25),#
      panel.border = element_rect(fill = "transparent", colour = "black", size = bordersize),#
      panel.grid.major.x = element_line(colour = grid.x_colour, size = 0.15, linetype = grid.x_linetype),#
      panel.grid.major.y = element_line(colour = grid.y_colour, size = 0.15, linetype = grid.y_linetype),#
      panel.grid.minor = element_blank(),#
      panel.margin = unit(0.75, "lines"),#
      strip.background = element_rect(fill = strip_colour, colour = "black", size = 0), # STRIP BACKGROUND#
      strip.text.x = element_text(family = base_family, size = base_size, face = "plain", colour = strip_text),#
      strip.text.y = element_text(family = base_family, size = base_size, face = "plain", angle = -90, colour = strip_text),#
      plot.background = element_rect(fill = background_colour, colour = background_colour),#
      plot.title = element_text(family = base_family, size = base_size * 1.1, vjust = 0, face = "bold")#
    ) +#
    border#
}#
#
# Auto-break a graph title#
#
# title <- "Hello"#
# title <- "When providers gave me instructions, they always asked me whether you would have any problems doing what you needed to do to take care of your illness or health condition."#
# maxTitle <- 58#
# numLines <- 5#
#
makeTitle <- function(title, titleLines = 2, maxTitle = 58){#
    n <- ceiling(nchar(title) / maxTitle)#
    if(nchar(title) / maxTitle > titleLines){#
       warningMessage <- paste0("The number of lines in your title is too few for the number of characters. Setting titleLines to ", ceiling(nchar(title) / maxTitle), ".")#
       warning(warningMessage)#
       titleLines <- ceiling(nchar(title) / maxTitle)#
    }#
    if(n == 1) return(paste0(c(rep("\n", titleLines - 1), title), collapse = ""))#
#
    newTitle <- ""#
    for(i in 1:(n-1)){#
        cutNear <- nchar(title)/(n+1-i)#
        cutAt <- unlist(gregexpr(" ", title))[which(abs(cutNear - unlist(gregexpr(" ", title))) == min(abs(cutNear - unlist(gregexpr(" ", title)))))] - 1#
        newTitle[i] <- substr(title, 1, cutAt)#
        title <- substr(title, cutAt+2, nchar(title))#
    }#
    newTitle <- paste(c(newTitle, title), collapse = "\n")#
#
    return(paste0(c(rep("\n", titleLines - n), newTitle), collapse = ""))#
}#
#
########## WEIGHT FUNCTION#
#
# Data <- Complete#
# WeightData <- W#
# variables <- c("voteChoice2013Labor",#
#                "weightGender",#
#                "weightAgeGroup",#
#                "weightEducation",#
#                "weightIndustry",#
#                "weightReligion",#
#                "weightVolunteer")#
# trim <- FALSE#
#
weight <- function(Data, WeightData, variables, trim = TRUE){#
    require(ebal)#
    require(plyr)#
#
    if(!all(variables %in% names(Data))){#
        stopMessage <- paste0("Dataset does not contain the following variables:\n ", variables[which(!variables %in% names(Data))])#
        stop(stopMessage)#
    }#
#
    if(!all(variables %in% names(WeightData))){#
        stopMessage <- paste0("Weighting dataset does not contain the following variables:\n ", variables[which(!variables %in% names(WeightData))])#
        stop(stopMessage)#
    }#
#
    makeBinary <- function(x, removeLast = TRUE){#
        categories <- unique(na.omit(x))#
        D <- matrix(ncol = length(categories), nrow = length(x))#
#
        for(i in 1:length(categories)){#
          D[, i] <- as.integer(x == categories[i])#
        }#
        invisible(gc())#
#
        if(removeLast == FALSE) return(D)#
        else if(removeLast == TRUE) return(D[, -ncol(D)])#
    }#
#
    Data$treatment <- 0#
    WeightData$treatment <- 1#
#
    missingRows <- which(apply(Data[, which(names(Data) %in% c("treatment", variables))], 1, function(X) any(is.na(X))))#
    if(length(missingRows > 0)) warning("Missing data in dataset.")#
#
    # Dataset which has missing data and cannot be weighted#
    MissingData <- data.frame()#
    if(length(missingRows) > 0){#
      MissingData <- Data[missingRows, ]#
      Data <- Data[-missingRows, ]#
    }#
    Merged <- rbind.fill(Data[, which(names(Data) %in% c("treatment", variables))],#
                         WeightData[, which(names(WeightData) %in% c("treatment", variables))])#
#
    treatment <- as.matrix(Merged$treatment); invisible(gc())#
#
    binaries <- names(Merged)[which(unlist(lapply(Merged, class)) %in% c("character", "factor"))]#
    continuous <- names(Merged)[which(unlist(lapply(Merged, class)) %in% c("numeric", "integer"))]#
    continuous <- continuous[-which(continuous == "treatment")]#
#
    X <- matrix(nrow = nrow(Merged), ncol = 0)#
#
    # BINARIES#
    if(length(binaries) > 0){#
      for(i in 1:length(binaries)){#
          X <- cbind(X, makeBinary(Merged[, binaries[i]], removeLast = TRUE))#
      }#
    }#
    invisible(gc())#
    # CONTINUOUS#
    if(length(continuous) > 0) X <- cbind(X, Merged[, continuous])#
#
    eb.out <- ebalance(Treatment = treatment, X = X)#
    invisible(gc())#
    if(trim == TRUE) eb.out <- ebalance.trim(eb.out)#
#
    Data$weight <- eb.out$w#
#
    if(nrow(MissingData) > 0) Data <- rbind.fill(Data, MissingData)#
    Data <- Data[, -which(names(Data) == "treatment")]#
    row.names(Data) <- 1:nrow(Data)#
    return(Data)#
#
}#
#
###########
########## BAR GRAPH (GENERIC)#
###########
# Data <- RegionBroadUndecided#
# yMax = NULL;#
# colour = RegionBroadColours;#
# fontsize = 11;#
# decimal = 0;#
# scale = 3;#
# ncol = NA;#
# sortCategories = FALSE;#
# title = "";#
# fill.horiz = "group1"#
barGraph <- function(Data, yMax = NULL, colour = NULL, fontsize = 11, decimal = 0, scale = 3, ncol = NA, sortCateType = "none", title = "", legend.position = "top", xlabels = NULL){#
  if(is.null(yMax)){#
    yMax <- max(Data$value)#
    yMax <- yMax + (0.16 * yMax)# Add 15% of the max to the y-axis height to leave room for number on top of bar#
  }#
  if(is.null(colour)) colour <- c("#86BADE", "#D86C58", "#49BB6C", "#C3A0C4", "#E3DB4A", "#C4758E", "#77B1A4", "grey40")#
#
  if(!is.factor(Data$group1)) Data$group1 <- factor(Data$group1, levels = unique(Data$group1))#
  levels(Data$group1) <- paste0(" ", levels(Data$group1), "  ")#
  if(!is.null(names(colour))) names(colour) <- paste0(" ", names(colour), "  ")#
  if(is.na(ncol)) ncol <- length(unique(Data$group1))#
  if(ncol > length(unique(Data$group1))) ncol <- length(unique(Data$group1))#
#
  # Sort category1 by a name of each category#
  if(sortCateType == "order") Data <- Data[with(Data, order(category1)),]#
  # Sort category1 descendingly by an overall mean value of each category#
  else if(sortCateType == "value") Data$category1 <- reorder(Data$category1, -Data$value, mean) #Data <- Data[with(Data, order())]#
#
  # Formatting the text of value labels for each bar graph by the number of decimal inputted#
  Data$valueLabel <- sprintf(paste0("%.", decimal, "f"), round(Data$value, decimal))#
  # xlabels is unspecified#
  if(is.null(xlabels)){#
    xbreaks <- unique(as.character(Data$category1))#
    xlabels <- unique(as.character(Data$category1))#
  # xlabels is specified as a vector#
  }else if(is.vector(xlabels)){#
    if(is.null(names(xlabels))) xbreaks <- unique(as.character(Data$category1))#
    else xbreaks <- names(xlabels)#
  # xlabels is specified as a data frame with the 1st column - an origional name of category1, #
  # the 2nd column - an new name of category1#
  }else if(is.data.frame(xlabels)){#
    xbreaks <- as.character(xlabels[,1])#
    xlabels <- as.character(xlabels[,2])#
  }#
#
  print(ggplot(Data, aes(x = category1, y = value, label = valueLabel, fill = group1, colour = group1)) +#
          my.theme(base_size = fontsize, borderless = 2,#
                   background_colour = "transparent", tick_colour = "#A0A4A2") +#
          coord_cartesian(y = c(0, yMax)) +#
          scale_y_continuous(breaks = c()) +#
          scale_x_discrete(breaks = xbreaks, labels = xlabels) +#
          labs(x = "", y = "", title = title, colour = "", fill = "") +#
          geom_bar(stat = "identity", fill = "transparent", position = position_dodge(width = 0.85), width = 0.6, size = 0.7, alpha = 1) +#
          geom_bar(stat = "identity", position = position_dodge(width = 0.87), width = 0.6, size = 0.7, alpha = 0.88) +#
          geom_text(colour = "grey15", stat = "identity", position = position_dodge(width = 0.85), size = (fontsize/scale), vjust = -0.85) +#
          geom_hline(yintercept = 0, colour = "#A0A4A2", size = 0.5) +#
          scale_fill_manual(values = colour) +#
          scale_colour_manual(values = colour) +#
          theme(plot.margin = unit(c(0, 0.5, -0.5, -1), "lines"),#
                legend.position = legend.position) +#
          guides(fill = guide_legend(ncol = ncol, byrow = TRUE,#
                 override.aes = list(colour = "transparent")#
                 ))#
       )#
#
}#
###########
########## CREATE GRAPH OF DAILY RESPONDENTS#
###########
#
dailyRespondents <- function(Data, language = "English", electionDay){#
  if(!"date" %in% names(Data)) stop("date does not exist")#
  title <- "Number of Users per Day"#
  electionName <- "Election"#
  if(language == "French"){#
    Sys.setlocale(locale="fr_CA.UTF-8")#
    title <- "Nombre d'utilisateurs"#
    electionName <- "élections"#
  }#
#
  require(scales)#
  G <- data.frame(table(Data$date), stringsAsFactors = FALSE)#
  names(G)[1] <- "date"#
  names(G)[2] <- "sampleSize"#
  G$date <- as.Date(as.character(G$date), format = "%Y%m%d")#
  missingDates <- seq(min(G$date), max(G$date), by = "days")[which(!seq(min(G$date), max(G$date), by = "days") %in% G$date)]#
  missingDates <- seq(min(G$date), as.Date(as.character(electionDay), "%Y%m%d"), by = "days")#
  missingDates <- missingDates[!missingDates %in% G$date]#
#
  if(length(missingDates) != 0){#
    G[nrow(G):nrow(G)+length(missingDates), ] <- NA#
    G$date[(nrow(G)-length(missingDates)+1):nrow(G)] <- missingDates#
  }#
#
  G$sampleSize[is.na(G$sampleSize)] <- 0#
#
  G$date <- factor(as.factor(G$date), levels = as.factor(seq(min(G$date, na.rm = TRUE), max(G$date, na.rm = TRUE), by = "days")))#
  dateNames <- format(as.Date(levels(G$date)), format="%b %d")#
  dateNames[dateNames == format(as.Date(as.character(electionDay), format = "%Y%m%d"), format="%b %d")] <- electionName#
#
  yMax <- ceiling(max(G$sampleSize, na.rm = TRUE)/10^(nchar(max(G$sampleSize, na.rm = TRUE))-1))*(10^(nchar(max(G$sampleSize, na.rm = TRUE))-1))#
#
  breakIntervals <- c(100, 250, 500, 1000, 2500, 5000, 10000, 25000, 50000, 100000, 250000, 500000, 1000000, 2500000)#
  breaks <- seq(0, yMax, by = breakIntervals[min(which(yMax / breakIntervals < 10))])#
#
  breakLabels <- format(breaks, big.mark=",")#
#
  if(language == "French") Sys.setlocale(locale="en_CA.UTF-8")#
#
  print(#
    ggplot(G, aes(x = date, y = sampleSize, width = 0.75)) +#
      my.theme(base_size = 11, borderless = 2, grid.y_colour = "grey90") +#
      coord_cartesian(y = c(0, yMax)) +#
      scale_x_discrete(labels = dateNames) +#
      scale_y_continuous(breaks = breaks, labels = breakLabels) +#
      labs(x = "", y = "", title = paste(title, "\n\n", sep = "")) +#
      geom_hline(yintercept = 0, size = 0.5) +#
      geom_bar(stat = "identity", colour = "black", size = 0.3, fill = "white", drop = TRUE) +#
      theme(legend.position = "none",#
            axis.ticks.y = element_line(colour = "transparent", size = 0),#
            axis.ticks.margin = unit(0.2, "cm"),#
            plot.margin = unit(c(0.5, 1.25, -0.25, 0.75), "lines"),#
            axis.text.x = element_text(angle=-45, vjust = 1.1, hjust = 0, size = 9))#
  )#
}#
#
###########
########## MAKE DATASET VARIABLES NUMERIC#
###########
#
makeNumeric <- function(X, varNames){#
  if(any(!varNames %in% names(X))) stop("Not all variables in dataset.")#
  for(i in 1:length(varNames)){#
    colNum <- which(names(X) == varNames[i])#
    X[, colNum] <- as.numeric(X[, colNum])#
  }#
  return(X)#
}#
#
###########
########## CLEAN CATEGORICAL VARIABLES#
###########
#
# varName <- M$industryRaw#
# category <- "industry"#
#
# varName <- M$voteChoicePartyLeaningRaw#
# category <- "voteChoicePartyLeaningRaw"#
# election <- "Queensland2015"#
# directory <- cleanDir#
cleanCatVar <- function(varName, category, election = "Canada", directory) {#
  ## This function is designed to clean raw categorical variables with values from a pre-existing, election-specific #
  ## master list of categories.#
#
  ## require(xlsx) package to load .xlsx files by sheet name#
  require(xlsx)#
#
  ## Set working directory to find election match .xlsx file#
  setwd(directory)#
#
  ## Load category list from .xlsx master list data file#
  pattern <- paste0("^",election, "Match")#
  fileName <- grep(pattern, list.files(), value = TRUE)#
  masterListData <- read.xlsx(fileName, sheetName = category, stringsAsFactors = FALSE, header = FALSE, encoding = "UTF-8")#
#
  ## Check data to make sure the categories of the variable are a proper subset of masterListData[, 1]#
  if(!all(varName[!is.na(varName)] %in% masterListData[, 1])) {#
    print(unique(na.omit(varName[!varName %in% masterListData[, 1]])))#
    stop("There are categories in the variable that are not in the matching file (SEE ABOVE WARNING MESSAGE)")#
  }#
  ## return a vector with the cleaned values that matches the previously uncleaned value order in the variable#
    return(masterListData[match(varName, masterListData[, 1]), 2])#
}#
#
###########
########## VOX POP LABS TABLE#
###########
#
vplTable <- function(x, by = NULL, weight = 1, label.x = NULL, label.by = NULL, label.category = NULL, by.subset = NULL, #
            type = c("across","within","means"), sortData = c("alphabet","rank","manual"), categoryOrder = NULL){#
  require(plyr)#
  require(survey)#
  DF = data.frame()#
  if(!is.null(by)) {D = data.frame(x, group1 = by, w = weight, stringsAsFactors = FALSE)#
  }else{ D = data.frame(x, group1 = "Overall", w = weight, stringsAsFactors = FALSE) }#
  #default Sort#
  sortData <- sortData[1]#
  #default type#
  type <- type[1]#
  # if by.subset is a data.frame, convert it to a vector #
  if(is.data.frame(by.subset)) by.subset <- as.vector(t(by.subset)) #
  # label.x is a vector #
  if(is.vector(label.x)){#
    if(length(label.x) != (ncol(D) -2)) {#
      stop("The length of labels.x does not match the number of variables.")#
    }#
    if(length(names(label.x)) > 0) { #
      label.x <- data.frame(variable = names(label.x), category1 = label.x) #
    }else{#
      label.x <- data.frame(variable = names(D)[1:(ncol(D)-2)], category1 = label.x)#
    }#
  }#
#
  if(is.data.frame(label.x)) names(label.x) <- c("variable", paste0("category", 1:(ncol(label.x) - 1)))#
    # label.by is a vector #
  if(is.vector(label.by)){#
    if(length(names(label.by)) > 0) { #
      label.by <- data.frame( group1 = names(label.by), group1Labels = label.by) #
    }else{#
      label.by <- data.frame(variable = names(D)[1:(ncol(D)-2)], category1 = label.by)#
    }#
  }#
#
  if(is.data.frame(label.by)) names(label.by) <- c("group1", "group1Labels")#
#
  if( !is.null(by.subset) ) D <- subset(D, group1 %in% by.subset)#
#
  if(is.numeric(D[,1])){#
    DF <- ddply(D, .(group1), function(X){ colwise(weighted.mean, names(X)[1:(ncol(X)-2)]) (X, na.rm = TRUE, w = X$w) })#
    DF <- melt(DF, id.vars = "group1", strinsAsFactors = FALSE)#
  }else{#
    Table <- svydesign(id = ~0, weights = ~ D$w, data = D)#
    for(i in 1: (ncol(D) - 2)){#
      variableOfInterest <- as.formula(paste0("~", names(D)[i], "+ group1"))#
      sum.by <- 2#
      if(type == "within") sum.by = 1#
      SingleQuestion <-   melt(prop.table(svytable(variableOfInterest, design = Table, Ntot = 100), sum.by), stringsAsFactors = FALSE)#
      SingleQuestion$value <- SingleQuestion$value * 100#
      names(SingleQuestion)[1] <- "category1"#
      SingleQuestion$variable <- names(D)[i]#
      DF <- rbind.fill(DF, SingleQuestion)#
    }#
    if( !is.null(label.x) ) names(label.x) <- c("variable", "variableRename")#
  }#
  if( !is.null(label.x) ) { #
    if( nrow(label.x) == 1 ) DF$variable <- label.x$variable#
    if( any(!DF$variable %in% label.x$variable)) stop("One of the variables in the data does not match the variables in label.x list.")#
    DF <- merge(DF, label.x, by = "variable", all = FALSE)#
  }#
  if( !is.null(label.by) ) DF <- merge(DF, label.by, by = "group1", all = FALSE)#
  if(!is.null(label.category)) { #
    names(DF)[names(DF) == "category1"] <- "category1Old"#
    names(label.category) <- c("variable", "category1Old", paste0("category", 1:(ncol(label.category) -2)))#
    DF <- merge(DF, label.category, by = c("variable","category1Old"), all = FALSE)#
  }#
  if(is.null(DF$category1)) DF$category1 <- DF$variable #
  if(sortData == "alphabet"){#
    DF$category1 <- as.character(DF$category1)#
    DF <- ddply(DF, .(variable,group1), function(X) X[order(X[,"category1"]),])#
  }else if(sortData == "rank"){#
    DF <- ddply(DF, .(variable,group1), function(X) X[order(X[,"value"]),])#
  }else if(sortData == "manual"){#
    DF$category1 <- factor(DF$category1, levels = categoryOrder)#
    DF <- ddply(DF, .(variable,group1), function(X) X[order(X[,"category1"]),])#
  }#
#
  if(!is.null(label.category)) {#
    for(i in 3:ncol(label.category)){#
      var <- paste0("category", (i-2))#
      DF[, var] <- factor(DF[,var], levels = unique(label.category[,i]))  #
    }#
  }#
  if( !is.null(label.category) ) DF$category1Old <- factor(DF$category1Old, levels = sort(unique(DF$category1Old)))#
  if( !is.null(by.subset) ) DF$group1 <- factor(DF$group1, levels = by.subset)#
  DF <- DF[, sort(names(DF))]#
#
  return(DF)#
}#
#
##### DOT PLOT#
#
vplDotPlot <- function(x, y, by, y.label = NULL, by.order = NULL, breaks = NULL, #
                      breaks.label = NULL, x.range = NA, colour = NULL, fontsize = 11, scale = 3, legend.col = NA, #
                      legend.position = "top", title = "", sortCateType = c("none", "order", "value")){#
  Data <- data.frame(value = x, category1 = y, group1 = by)#
  if(is.null(colour)) colour <- c("#86BADE", "#D86C58", "#49BB6C", "#C3A0C4", "#E3DB4A", "#C4758E", "#77B1A4", "grey40")#
  if(!is.null(names(colour))) names(colour) <- paste0(" ", names(colour), "  ") #
  levels(Data$group1) <- paste0(" ", levels(Data$group1), "  ")#
  if(is.na(legend.col)) legend.col <- length(levels(Data$group1))#
#
  if(is.null(breaks)) { #
    xlabels <- scale_x_continuous()#
  }else{#
    if( is.null(breaks.label)) {#
      xlabels <- scale_x_continuous(breaks = breaks)#
    }else{#
      xlabels <- scale_x_continuous(breaks = breaks, labels = breaks.label)#
    }#
  }#
#
  if(is.vector(y.label)){#
    if(length(y.label) != length(unique(as.character(y)))){#
      stop("The length of y.label does not match the number of categories")#
    }#
    if(length(names(y.label)) > 0 ){#
      y.label <- data.frame(oldCategory1 = names(y.label), category1 = y.label)#
    }else{#
      y.label <- data.frame(oldCategory1 = unique(as.character(Data$category1)), category1 = y.label)#
    }#
  }#
#
  if(is.data.frame(y.label)) names(y.label) <- c("oldCategory1", "category1")#
  if(!is.null(y.label)) Data <- merge(y.label, Data, by.x = "oldCategory1", by.y = "category1")  #
  sortCateType <- sortCateType[1]#
  # Sort category1 by a name of each category#
  if(sortCateType == "order") Data <- Data[with(Data, order(category1)),]#
  # Sort category1 descendingly by an overall mean value of each category#
  else if(sortCateType == "value") Data$category1 <- reorder(Data$category1, Data$value, mean) #
  if(is.na(x.range)){#
    xMax <- max(Data$value) + 0.05*diff(range(Data$value))#
    xMin <- min(Data$value) - 0.05*diff(range(Data$value))#
  }else{#
    xMax <- range[2]#
    xMin <- range[1]#
  }#
  if(!is.null(breaks)) {#
    xMax <- max(breaks[length(breaks)], xMax)#
    xMin <- min(breaks[1], xMin)#
  }#
#
  print(ggplot(Data, aes(x = value, y = category1, fill = group1, colour = group1)) +#
          my.theme(base_size = fontsize, borderless = 2,#
                   grid.x_colour = "grey80", grid.y_colour = "grey80",#
                   grid.x_linetype = 1,      grid.y_linetype = 1,#
                   background_colour = "#EDf4F7", tick_colour = "grey80") +#
          coord_cartesian(x = c(xMin, xMax))+#
          xlabels + #
          labs(x = "", y = "", colour = "", fill = "") +#
          geom_point(pch = 21, size = 3.5, fill = "transparent", alpha = 1) +#
          geom_point(pch = 21, size = 3.5, alpha = 0.7)  +#
          scale_fill_manual(values = colour) +#
          scale_colour_manual(values = colour) +#
          theme(legend.position = "top",#
                legend.key.size = unit(0.8, "lines"),#
                legend.text = element_text(size = fontsize, face = "italic"),#
                legend.background = element_rect(colour = "grey15", fill = "transparent", size = 0.25),#
                axis.ticks.length = unit(0, "lines"),#
                plot.margin = unit(c(0, 3, 0, 0), "lines")) +#
          guides(fill = guide_legend(ncol = legend.col, byrow = TRUE)) )#
}
library(chron)#
#
workingDirectory <- "~/Dropbox (Vox Pop Labs)/Data/VoteCompass/Queensland2015"#
setwd(paste0(workingDirectory, "/RawData"))#
#
dataList <- sort(grep("report", list.files(), ignore.case = FALSE, value = TRUE), decreasing = TRUE)#
# dataList <- dataList[!dataList %in% c("")]#
#
## ELECTION DAY INFORMATION#
#
startDay <- 20150113#
electionDay <- 20150131#
#
## LOAD DATA#
#
n <- length(dataList)#
M <- data.frame()#
for(i in 1:n){#
  cat(c(length(dataList) - i + 1, sort(dataList)[i], "\n"))#
  M <- rbind.fill(M, read.csv(sort(dataList)[i], stringsAsFactor = FALSE, fileEncoding = "UTF-8", na.strings = c("NA", "", "Please select", "Please Select"), allowEscapes = TRUE, flush = TRUE))#
}#
M <- M[!duplicated(M) & M$dateStamp != "2015-01-11", ] #
#
# if(length(which(duplicated(M$session_id))) > 0) M <- M[-which(duplicated(M$session_id)), ]#
#
setwd(workingDirectory)#
#
nrow(M)#
#
# COUNTRY#
M$country <- "Australia"#
#
# STATE#
M$state <- "Queensland"#
## LANGUAGE OF USE#
#
names(M)[names(M) == "Language"] <- "languageOfUse"#
#
M$languageOfUse[M$languageOfUse == 1] <- "English"#
M <- subset(M, !is.na(languageOfUse))#
#
M$dateTime <- chron(dates = M$dateStamp, times = M$timeStamp, format = c(dates = "y-m-d", times = "h:m:s"))#
M$dateTime <- chron(as.numeric(M$dateTime) + as.numeric(times("14:00:00")), format = c(dates = "y-m-d", times = "h:m:s")) # AST is 14 hours ahead of EST.#
#
M <- M[order(M$dateTime),]#
M <- M[M$dateTime >= dates("15-01-13", format = "y-m-d"),]#
## DATE#
M$date <- paste0("20", gsub("-", "", as.character(dates(M$dateTime))))
## TIME#
M$time <- substr(as.character(M$dateTime), 11, 18)#
#
# Makes use of functions from 'chron' package#
M$seconds <- seconds(M$dateTime) + (minutes(M$dateTime)*60) + (hours(M$dateTime)*3600)#
#
## DISTRICT ID#
M$district_id[M$district_id == 0] <- NA#
#
## POSTAL CODE#
# M$postal_code <- gsub("[^0-9]", "", M$postal_code) #
# M$postal_code[nchar(M$postal_code) != 4] <- NA#
M$postal_code <- gsub("^[\\s+ \\. A-Z a-z \\`]|[\\s+ \\/ A-Z a-z \\( \\#]$", "", M$postal_code)#
M$postal_code[apply(as.matrix(M$postal_code),1, nchar) != 4 | grepl("[0-9][0-9][0-9][0-9]", M$postal_code) == FALSE] <- NA#
#
# M$postal_code <- gsub(" ", "", M$p)#
# M$postal_code <- toupper(gsub(" ", "", M$postal_code))#
#
valsqd2 <- c("Woman","Man", NA)#
valsqd3 <- c("1982", "1975", "1990", "1980", "1993", "1988", "1994", "1995", "1969", "1987", "1983", "1977", "1961", "1992", "1952", "1996", "1968", "1984", "1986", "1960", #
 "1981", "1972", "1979", "1965", "1978", "1989", "1971", "1963", "2000", "1997", "1967", "1951", "1999", "1955", "1954", "1948", "1949", "1958", "1985", "1976", #
 "1953", "1973", "1950", "1964", "1974", "1998", "1966", "1962", "1991", "1970", "1956", "1957", "1939", "1946", "1938", "1941", "1959", "1944", "1945", "1940", #
 "1947", "1943", "1942", "2001", "1937", "1931", "1936", "2004", "1933", "1935", "1932", "1900", "1927", "2003", "2002", "1934", "2014", "1928", "1901", "1929", #
 "1930", "1926", "1923", "2011", "1921", "1925", "2005", "1924", "1918", "1913", "1922", "1915", "1919", "2007", "1920", "2010", "1916", "2008", "2013", "1904", #
 "1914", "2006", "1912", "1903", "1909", NA)#
valsqd4 <- c("Master Degree Level", "Bachelor Degree Level", "Year 12", "Graduate Diploma Level", "Doctoral Degree Level", #
  "Advanced Diploma and Associate Degree Level", "Year 10", "Certificate III", "Graduate Certificate Level", "Year 9" , #
  "Year 11", "Diploma Level", "Certificate I" , "Certificate IV", "Certificate II", "Year 8 or below", NA)#
valsqd5 <-  c("No", "Full-time student", "Part-time student", NA)#
#
valsqd6 <- c(#
"Information media and telecommunications",#
"Stay-at-home parent",#
"Professional, scientific, and technical services",#
"Accommodation and food services",#
"Agriculture, forestry, and fishing",#
"Retail trade",#
"Arts and recreation services",#
"Mining",#
"Student without other employment",#
"Other services",#
"Wholesale trade",#
"Administrative and support services",#
"Public administration and safety",#
"Health care and social assistance",#
"Education and training",#
"Unemployed (searching for employment)",#
"Financial and insurance services",#
"Retired",#
"Electricity, gas, water, and waste services",#
"Transport, postal, and warehousing",#
"Manufacturing",#
"Rental, hiring, and real estate services",#
"Unemployed (not currently searching for employment)",#
"Construction", NA)#
#
valsqd7 <- c("Somewhat interested","Very interested","Not very interested","Not at all interested", NA)#
#
valsqd8 <- c( "Daily", "Rarely", "Several times each week", "Several times each month", "Never", NA)#
#
valsqd10 <- c(#
"Liberal National Party of Queensland",#
"I did not vote",#
"Other party or candidate",#
"I do not remember",#
"Australian Labor Party - State of Queensland",#
"Queensland Greens",#
"Katter's Australian Party",#
"Palmer United Party",#
"One Nation Queensland Division",#
"Family First Party - Queensland Division",#
"I spoiled my ballot", NA#
)#
#
valsqd13 <- c( "Not very important", "Very important", "Not important at all", "Somewhat important", NA)#
#
valsqd14 <- c(6, 4, 5, 3, 7, 2, 1, 0, 8, 10, 9, NA )#
#
valsqd18 <- c( #
"$3,000 to $3,499 per week (or $156,000 to $181,999 per year)",#
"$1,500 to $1,999 per week (or $78,000 to $103,999 per year)",#
"$1,000 to $1,249 per week (or $52,000 to $64,999 per year)",#
"$2,500 to $2,999 per week (or $130,000 to $155,999 per year)",#
"$1,250 to $1,499 per week (or $65,000 to $77,999 per year)",#
"$800 to $999 dollars per week (or $41,600 to $51,999 per year)",#
"$300 to $399 per week (or $15,600 to $20,799 per year)",#
"$5,000 or more per week (or $260,000 or more per year)",#
"$2,000 to $2,499 per week (or $104,000 to $129,999 per year)",#
"$400 to $599 per week (or $20,800 to $31,199 per year)",#
"$200 to $299 per week (or $10,400 to $15,599 per year)",#
"$4,000 to $4,999 per week (or $208,000 to $259,999 per year)",#
"$3,500 to $3,999 per week (or $182,000 to $207,999 per year)",#
"$600 to $799 per week (or $31,200 to $41,599 per year)",#
"$1 to $199 per week (or $1 to $10,399 per year)",#
"Nil or negative income", NA#
)#
valsq27s <- c("0","6","7","5","3","9","8","10","4","2","1", NA)#
valsq28s <- c("0","6","7","5","3","9","8","10","4","2","1", NA) #
valsq29s <- c("0","10","8","3","7","5","4","1","9","6","2", NA)#
#
valsq30s <- c("0","5","7","6","10","4","8","9","2","1","3", NA)#
#
valsList <- list(valsqd2, valsqd3, valsqd4, valsqd5, valsqd6, valsqd7, valsqd8, valsqd10, valsqd13, valsqd14, valsqd18, valsq27s, valsq28s, valsq29s, valsq30s)#
valsMatrix <- M[, c("qd2", "qd3", "qd4", "qd5", "qd6", "qd7", "qd8", "qd10", "qd13", "qd14", "qd18", "q27s", "q28s", "q29s", "q30s" )]                          #
#
idx <- apply(as.matrix(1:15), 1, function(x) (valsMatrix[,x] %in% valsList[[x]]))#
idxF <- apply(idx, 1, function(x) sum(x) < 15)#
#
M <- M[!idxF, ]
nrow(M)
ncol(M)
names(M)
QueenslandRaw <- M[sample(1:nrow(M),10000), ]
dim(QueenslandRaw)
library(devtools)
setwd("~/Desktop/R Packages/pplpredict")
library(pplpredict)
cleanData <- function(Data, varsClean, matchFileName){#
#
    if(!basename(MatchFileName) %in% list.file(dirname(MatchFileName))) { #
        stop(paste0(MatchFileName, " does not exist."))#
    }else{ #
        if(!grep("\\.xlsx", MatchFileName, ignore.case = TRUE)) stop("The MatchFileName must have a xlsx extension.") #
        for(i in 1:length(varsClean)){#
            matchFile <- xlsx::read.xlsx2(MatchFileName, sheetNames = varsClean[i], stringsAsFactors = FALSE)#
            Data <- data.frame(Data, recategorize(Data[,varsClean[i]], matchFile, labels = paste0(gsub("Raw","", varsClean[i]),1:ncol(matchFile))))#
        }#
    }#
    Data#
}
names(M)[names(M) == "qd2"] <- "genderRaw"
names(M)[names(M) == "qd4"] <- "educationRaw"
names(M)[names(M) == "qd5"] <- "studentRaw"
names(QueenslandRaw)[names(Queesland) == "qd5"] <- "studentRaw"
names(QueenslandRaw)[names(QueeslandRaw) == "qd5"] <- "studentRaw"
head(QueenslandRaw)
names(QueenslandRaw)[names(Queensland) == "qd5"] <- "studentRaw"
names(QueenslandRaw)[names(QueenslandRaw) == "qd5"] <- "studentRaw"
names(QueenslandRaw)[names(QueenslandRaw) == "qd4"] <- "educationRaw"
names(QueenslandRaw)[names(QueenslandRaw) == "qd2"] <- "genderRaw"
cleanData <- function(Data, varsClean, matchFileName){#
#
    if(!basename(MatchFileName) %in% list.file(dirname(MatchFileName))) { #
        stop(paste0(MatchFileName, " does not exist."))#
    }else{ #
        if(!grep("\\.xlsx", MatchFileName, ignore.case = TRUE)) stop("The MatchFileName must have a xlsx extension.") #
        for(i in 1:length(varsClean)){#
            matchFile <- xlsx::read.xlsx2(MatchFileName, sheetNames = varsClean[i], stringsAsFactors = FALSE)#
            Data <- data.frame(Data, recategorize(Data[,varsClean[i]], matchFile, labels = paste0(gsub("Raw","", varsClean[i]),1:ncol(matchFile))))#
        }#
    }#
    Data#
}
NewData <- cleanData(QueenslandRaw, c("genderRaw","studentRaw","educationRaw"), "~/Desktop/R Packages/QueenslandMatch.xlsx")
cleanData <- function(Data, varsClean, matchFileName){#
#
    if(!basename(matchFileName) %in% list.file(dirname(matchFileName))) { #
        stop(paste0(matchFileName, " does not exist."))#
    }else{ #
        if(!grep("\\.xlsx", matchFileName, ignore.case = TRUE)) stop("The matchFileName must have a xlsx extension.") #
        for(i in 1:length(varsClean)){#
            matchFile <- xlsx::read.xlsx2(MatchFileName, sheetNames = varsClean[i], stringsAsFactors = FALSE)#
            Data <- data.frame(Data, recategorize(Data[,varsClean[i]], matchFile, labels = paste0(gsub("Raw","", varsClean[i]),1:ncol(matchFile))))#
        }#
    }#
    Data#
}
NewData <- cleanData(QueenslandRaw, c("genderRaw","studentRaw","educationRaw"), "~/Desktop/R Packages/QueenslandMatch.xlsx")
cleanData <- function(Data, varsClean, matchFileName){#
#
    if(!basename(matchFileName) %in% list.files(dirname(matchFileName))) { #
        stop(paste0(matchFileName, " does not exist."))#
    }else{ #
        if(!grep("\\.xlsx", matchFileName, ignore.case = TRUE)) stop("The matchFileName must have a xlsx extension.") #
        for(i in 1:length(varsClean)){#
            matchFile <- xlsx::read.xlsx2(MatchFileName, sheetNames = varsClean[i], stringsAsFactors = FALSE)#
            Data <- data.frame(Data, recategorize(Data[,varsClean[i]], matchFile, labels = paste0(gsub("Raw","", varsClean[i]),1:ncol(matchFile))))#
        }#
    }#
    Data#
}
NewData <- cleanData(QueenslandRaw, c("genderRaw","studentRaw","educationRaw"), "~/Desktop/R Packages/QueenslandMatch.xlsx")
?xlsx
read.xlsx
?read.xlsx
cleanData <- function(Data, varsClean, matchFileName){#
#
    if(!basename(matchFileName) %in% list.files(dirname(matchFileName))) { #
        stop(paste0(matchFileName, " does not exist."))#
    }else{ #
        if(!grep("\\.xlsx", matchFileName, ignore.case = TRUE)) stop("The matchFileName must have a xlsx extension.") #
        for(i in 1:length(varsClean)){#
            matchFile <- xlsx::read.xlsx2(MatchFileName, sheetName = varsClean[i], stringsAsFactors = FALSE)#
            Data <- data.frame(Data, recategorize(Data[,varsClean[i]], matchFile, labels = paste0(gsub("Raw","", varsClean[i]),1:ncol(matchFile))))#
        }#
    }#
    Data#
}
NewData <- cleanData(QueenslandRaw, c("genderRaw","studentRaw","educationRaw"), "~/Desktop/R Packages/QueenslandMatch.xlsx")
cleanData <- function(Data, varsClean, matchFileName){#
#
    if(!basename(matchFileName) %in% list.files(dirname(matchFileName))) { #
        stop(paste0(matchFileName, " does not exist."))#
    }else{ #
        if(!grep("\\.xlsx", matchFileName, ignore.case = TRUE)) stop("The matchFileName must have a xlsx extension.") #
        for(i in 1:length(varsClean)){#
            matchFile <- xlsx::read.xlsx2(matchFileName, sheetName = varsClean[i], stringsAsFactors = FALSE)#
            Data <- data.frame(Data, recategorize(Data[,varsClean[i]], matchFile, labels = paste0(gsub("Raw","", varsClean[i]),1:ncol(matchFile))))#
        }#
    }#
    Data#
}
NewData <- cleanData(QueenslandRaw, c("genderRaw","studentRaw","educationRaw"), "~/Desktop/R Packages/QueenslandMatch.xlsx")
Data <- QueenslandRaw#
varsClean <- c("genderRaw","studentRaw","educationRaw")#
matchFileName <- "~/Desktop/R Packages/QueenslandMatch.xlsx"
!basename(matchFileName) %in% list.files(dirname(matchFileName))
if(!grep("\\.xlsx", matchFileName, ignore.case = TRUE)) stop("The matchFileName must have a xlsx extension.")
1:length(varsClean)
i <- 1
matchFile <- xlsx::read.xlsx2(matchFileName, sheetName = varsClean[i], stringsAsFactors = FALSE)
matchFile
matchFile <- xlsx::read.xlsx2(matchFileName, sheetName = varsClean[i], stringsAsFactors = FALSE, header = FALSE)
matchFile
matchFile <- xlsx::read.xlsx2(matchFileName, sheetName = varsClean[i], stringsAsFactors = FALSE, header = header)#
            Data <- data.frame(Data, recategorize(Data[,varsClean[i]], matchFile, labels = paste0(gsub("Raw","", varsClean[i]),1:ncol(matchFile))))
paste0(gsub("Raw","", varsClean[i]),1:ncol(matchFile))
recategorize <- function(x, x.new, labels = NA){#
#
    if(is.vector(x.new)){#
        if(is.null(names(x.new))) stop("Each new value in x.new must be corresponding to a value in the original x.")#
        new.names <- as.matrix(x.new)#
        rownames(new.names) <- names(x.new) #
    }else if(!is.matrix(x.new) & !is.data.frame(x.new) ){ #
        stop("The type of x.new is not correct. x.new must be a vector, a matrix or a data.frame, #
             where the 1st column is the original value of x and the 2nd is the new value of x.")#
    }else{#
        new.names <- as.matrix(x.new[,-1])#
        rownames(new.names) <- x.new[,1]#
        x.new <- new.names#
    } #
    uniqueVals <- unique(x[!is.na(x)])#
    if(any(!uniqueVals %in% rownames(new.names)) ) {#
        x[x %in% uniqueVals[!uniqueVals %in% rownames(new.names)]] <- NA#
        msg <- paste0("These values: ", paste0(uniqueVals[!uniqueVals %in% rownames(new.names)], collapse = ", "), #
                             " are not the original values in x. These values are replaced by missing values.")#
        warning(msg)#
    }#
    if(is.na(labels)) labels <- paste0("X",1:ncol(new.names))#
    colnames(new.names) <- labels#
    data.frame(new.names[x,], row.names = NULL)#
}
cleanData <- function(Data, varsClean, matchFileName, ...){#
#
    if(!basename(matchFileName) %in% list.files(dirname(matchFileName))) { #
        stop(paste0(matchFileName, " does not exist."))#
    }else{ #
        if(!grep("\\.xlsx", matchFileName, ignore.case = TRUE)) stop("The matchFileName must have a xlsx extension.") #
        for(i in 1:length(varsClean)){#
            if(!"header" %in% names(match.call())) header = FALSE#
            matchFile <- xlsx::read.xlsx2(matchFileName, sheetName = varsClean[i], stringsAsFactors = FALSE, header = header)#
            Data <- data.frame(Data, recategorize(Data[,varsClean[i]], matchFile, labels = paste0(gsub("Raw","", varsClean[i]),1:ncol(matchFile))))#
        }#
    }#
    Data#
}
NewData <- cleanData(QueenslandRaw, c("genderRaw","studentRaw","educationRaw"), "~/Desktop/R Packages/QueenslandMatch.xlsx")
cleanData <- function(Data, varsClean, matchFileName, ...){#
#
    if(!basename(matchFileName) %in% list.files(dirname(matchFileName))) { #
        stop(paste0(matchFileName, " does not exist."))#
    }else{ #
        if(!grep("\\.xlsx", matchFileName, ignore.case = TRUE)) stop("The matchFileName must have a xlsx extension.") #
        for(i in 1:length(varsClean)){#
            if(!"header" %in% names(match.call())) header = FALSE#
            matchFile <- xlsx::read.xlsx2(matchFileName, sheetName = varsClean[i], stringsAsFactors = FALSE, header = header)#
            Data <- data.frame(Data, recategorize(Data[,varsClean[i]], matchFile, labels = paste0(gsub("Raw","", varsClean[i]),1:ncol(matchFile[,-1]))))#
        }#
    }#
    Data#
}
NewData <- cleanData(QueenslandRaw, c("genderRaw","studentRaw","educationRaw"), "~/Desktop/R Packages/QueenslandMatch.xlsx")
cleanData <- function(Data, varsClean, matchFileName, ...){#
#
    if(!basename(matchFileName) %in% list.files(dirname(matchFileName))) { #
        stop(paste0(matchFileName, " does not exist."))#
    }else{ #
        if(!grep("\\.xlsx", matchFileName, ignore.case = TRUE)) stop("The matchFileName must have a xlsx extension.") #
        for(i in 1:length(varsClean)){#
            if(!"header" %in% names(match.call())) header = FALSE#
            matchFile <- xlsx::read.xlsx2(matchFileName, sheetName = varsClean[i], stringsAsFactors = FALSE, header = header)#
            Data <- data.frame(Data, recategorize(Data[,varsClean[i]], matchFile, labels = paste0(gsub("Raw","", varsClean[i]),1:(ncol(matchFile)-1))))#
        }#
    }#
    Data#
}
NewData <- cleanData(QueenslandRaw, c("genderRaw","studentRaw","educationRaw"), "~/Desktop/R Packages/QueenslandMatch.xlsx")
Data <- QueenslandRaw#
varsClean <- c("genderRaw","studentRaw","educationRaw")#
matchFileName <- "~/Desktop/R Packages/QueenslandMatch.xlsx"
if(!grep("\\.xlsx", matchFileName, ignore.case = TRUE)) stop("The matchFileName must have a xlsx extension.")
if(!"header" %in% names(match.call())) header = FALSE
matchFile <- xlsx::read.xlsx2(matchFileName, sheetName = varsClean[i], stringsAsFactors = FALSE, header = header)
args <- match.call()#
            if(!"header" %in% names(args)) header = FALSE
Data <- QueenslandRaw#
varsClean <- c("genderRaw","studentRaw","educationRaw")#
matchFileName <- "~/Desktop/R Packages/QueenslandMatch.xlsx"
if(!grep("\\.xlsx", matchFileName, ignore.case = TRUE)) stop("The matchFileName must have a xlsx extension.")
args <- match.call()
matchFile <- xlsx::read.xlsx2(matchFileName, sheetName = varsClean[i], stringsAsFactors = FALSE, header = header)
Data <- QueenslandRaw#
varsClean <- c("genderRaw","studentRaw","educationRaw")#
matchFileName <- "~/Desktop/R Packages/QueenslandMatch.xlsx"#
header <- FALSE
matchFile <- xlsx::read.xlsx2(matchFileName, sheetName = varsClean[i], stringsAsFactors = FALSE, header = header)
matchFile
Data <- data.frame(Data, recategorize(Data[,varsClean[i]], matchFile, labels = paste0(gsub("Raw","", varsClean[i]),1:(ncol(matchFile)-1))))
unique(Data$genderRaw)
paste0(gsub("Raw","", varsClean[i]),1:(ncol(matchFile)-1))
head(Data[,varsClean[i]])
matchFile
recategorize <- function(x, x.new, labels = NA){#
#
    if(is.vector(x.new)){#
        if(is.null(names(x.new))) stop("Each new value in x.new must be corresponding to a value in the original x.")#
        new.names <- as.matrix(x.new)#
        rownames(new.names) <- names(x.new) #
    }else if(!is.matrix(x.new) & !is.data.frame(x.new) ){ #
        stop("The type of x.new is not correct. x.new must be a vector, a matrix or a data.frame, #
             where the 1st column is the original value of x and the 2nd is the new value of x.")#
    }else{#
        new.names <- as.matrix(x.new[,-1])#
        rownames(new.names) <- x.new[,1]#
        x.new <- new.names#
    } #
    uniqueVals <- unique(x[!is.na(x)])#
    if(any(!uniqueVals %in% rownames(new.names)) ) {#
        x[x %in% uniqueVals[!uniqueVals %in% rownames(new.names)]] <- NA#
        msg <- paste0("These values: ", paste0(uniqueVals[!uniqueVals %in% rownames(new.names)], collapse = ", "), #
                             " are not the original values in x. These values are replaced by missing values.")#
        warning(msg)#
    }#
    if(is.na(labels)) labels <- paste0("X",1:ncol(new.names))#
    colnames(new.names) <- labels#
    data.frame(new.names[x,], row.names = NULL)#
}
recategorize(Data[,varsClean[i]], matchFile, labels = paste0(gsub("Raw","", varsClean[i]),1:(ncol(matchFile)-1)))
recategorize <- function(x, x.new, labels = NA){#
#
    if(is.vector(x.new)){#
        if(is.null(names(x.new))) stop("Each new value in x.new must be corresponding to a value in the original x.")#
        new.names <- as.matrix(x.new)#
        rownames(new.names) <- names(x.new) #
    }else if(!is.matrix(x.new) & !is.data.frame(x.new) ){ #
        stop("The type of x.new is not correct. x.new must be a vector, a matrix or a data.frame, #
             where the 1st column is the original value of x and the 2nd is the new value of x.")#
    }else{#
        new.names <- as.matrix(x.new[,-1])#
        rownames(new.names) <- x.new[,1]#
        x.new <- new.names#
    } #
    uniqueVals <- unique(x[!is.na(x)])#
    if(any(!uniqueVals %in% rownames(new.names)) ) {#
        x[x %in% uniqueVals[!uniqueVals %in% rownames(new.names)]] <- NA#
        msg <- paste0("These values: ", paste0(uniqueVals[!uniqueVals %in% rownames(new.names)], collapse = ", "), #
                             " are not the original values in x. These values are replaced by missing values.")#
        warning(msg)#
    }#
    if(is.na(labels)) labels <- paste0("X",1:ncol(new.names))#
    colnames(new.names) <- labels#
    new.names[x,]#
}
head(recategorize(Data[,varsClean[i]], matchFile, labels = paste0(gsub("Raw","", varsClean[i]),1:(ncol(matchFile)-1))))
i <- 1
matchFile <- xlsx::read.xlsx2(matchFileName, sheetName = varsClean[i], stringsAsFactors = FALSE, header = header)#
            Data <- data.frame(Data, recategorize(Data[,varsClean[i]], matchFile, labels = paste0(gsub("Raw","", varsClean[i]),1:(ncol(matchFile)-1))))
matchFile
head(Data[,varsClean[i]])
x <- Data[,varsClean[i]]
x.new <- matchFile
labels <- paste0(gsub("Raw","", varsClean[i]),1:(ncol(matchFile)-1))
labels
if(is.vector(x.new)){#
        if(is.null(names(x.new))) stop("Each new value in x.new must be corresponding to a value in the original x.")#
        new.names <- as.matrix(x.new)#
        rownames(new.names) <- names(x.new) #
    }else if(!is.matrix(x.new) & !is.data.frame(x.new) ){ #
        stop("The type of x.new is not correct. x.new must be a vector, a matrix or a data.frame, #
             where the 1st column is the original value of x and the 2nd is the new value of x.")#
    }else{#
        new.names <- as.matrix(x.new[,-1])#
        rownames(new.names) <- x.new[,1]#
        x.new <- new.names#
    }
x.new
new.names
uniqueVals <- unique(x[!is.na(x)])
uniqueVals
any(!uniqueVals %in% rownames(new.names))
if(is.na(labels)) labels <- paste0("X",1:ncol(new.names))
labels
colnames(new.names) <- labels
new.names
head(new.names[x,])
class(x)
class(x.new)
class(new.names)
head(x)
new.names[head(x),]
new.names[x,]
new.names[x[1:100],]
new.names[x[1:10],]
x[1:10]
new.names[x[1:10],]
new.names[x[1:8],]
new.names[x[1:7],]
str(x)
is.na(head(x))
is.na(x[1:10])
x[!is.na(x)]
if(is.vector(x.new)){#
        if(is.null(names(x.new))) stop("Each new value in x.new must be corresponding to a value in the original x.")#
        new.names <- as.matrix(x.new)#
        rownames(new.names) <- names(x.new) #
    }else if(!is.matrix(x.new) & !is.data.frame(x.new) ){ #
        stop("The type of x.new is not correct. x.new must be a vector, a matrix or a data.frame, #
             where the 1st column is the original value of x and the 2nd is the new value of x.")#
    }else{#
        new.names <- data.frame(x.new[,-1])#
        rownames(new.names) <- x.new[,1]#
        x.new <- new.names#
    } #
    uniqueVals <- unique(x[!is.na(x)])
uniqueVals
if(is.na(labels)) labels <- paste0("X",1:ncol(new.names))
names(new.names) <- labels
new.names
i <- 1#
x <- Data[,varsClean[i]]#
x.new <- matchFile#
labels <- paste0(gsub("Raw","", varsClean[i]),1:(ncol(matchFile)-1))
if(is.vector(x.new)){#
        if(is.null(names(x.new))) stop("Each new value in x.new must be corresponding to a value in the original x.")#
        new.names <- as.matrix(x.new)#
        rownames(new.names) <- names(x.new) #
    }else if(!is.matrix(x.new) & !is.data.frame(x.new) ){ #
        stop("The type of x.new is not correct. x.new must be a vector, a matrix or a data.frame, #
             where the 1st column is the original value of x and the 2nd is the new value of x.")#
    }else{#
        new.names <- data.frame(x.new[,-1])#
        rownames(new.names) <- x.new[,1]#
        x.new <- new.names#
    }
new.names
x.new
if(is.na(labels)) labels <- paste0("X",1:ncol(new.names))
x.new
new.names
names(new.names) <- labels
new.naems
new.names
D <- new.names[x, ]
head(D)
D <- new.names[x, ]
recategorize <- function(x, x.new, labels = NA){#
#
    if(is.vector(x.new)){#
        if(is.null(names(x.new))) stop("Each new value in x.new must be corresponding to a value in the original x.")#
        new.names <- as.matrix(x.new)#
        rownames(new.names) <- names(x.new) #
    }else if(!is.matrix(x.new) & !is.data.frame(x.new) ){ #
        stop("The type of x.new is not correct. x.new must be a vector, a matrix or a data.frame, #
             where the 1st column is the original value of x and the 2nd is the new value of x.")#
    }else{#
        new.names <- data.frame(x.new[,-1])#
        rownames(new.names) <- x.new[,1]#
        x.new <- new.names#
    } #
    uniqueVals <- unique(x[!is.na(x)])#
    if(any(!uniqueVals %in% rownames(new.names)) ) {#
        x[x %in% uniqueVals[!uniqueVals %in% rownames(new.names)]] <- NA#
        msg <- paste0("These values: ", paste0(uniqueVals[!uniqueVals %in% rownames(new.names)], collapse = ", "), #
                             " are not the original values in x. These values are replaced by missing values.")#
        warning(msg)#
    }#
    if(is.na(labels)) labels <- paste0("X",1:ncol(new.names))#
    names(new.names) <- labels#
    D <- data.frame(new.names[x, ], stringsAsFactors = FALSE)#
    D#
}
NewData <- cleanData(QueenslandRaw, c("genderRaw","studentRaw","educationRaw"), "~/Desktop/R Packages/QueenslandMatch.xlsx")
head(NewData)
cleanData <- function(Data, varsClean, matchFileName, ...){#
#
    if(!basename(matchFileName) %in% list.files(dirname(matchFileName))) { #
        stop(paste0(matchFileName, " does not exist."))#
    }else{ #
        if(!grep("\\.xlsx", matchFileName, ignore.case = TRUE)) stop("The matchFileName must have a xlsx extension.") #
        for(i in 1:length(varsClean)){#
            args <- match.call()#
            if(!"header" %in% names(args)) header = FALSE#
            matchFile <- xlsx::read.xlsx2(matchFileName, sheetName = varsClean[i], stringsAsFactors = FALSE, header = header)#
            Data <- data.frame(Data, recategorize(Data[,varsClean[i]], matchFile, labels = paste0(gsub("Raw","", varsClean[i]),1:(ncol(matchFile)-1))))#
        }#
    }#
    Data#
}
recategorize <- function(x, x.new, labels = NA){#
#
    if(is.vector(x.new)){#
        if(is.null(names(x.new))) stop("Each new value in x.new must be corresponding to a value in the original x.")#
        new.names <- as.matrix(x.new)#
        rownames(new.names) <- names(x.new) #
    }else if(!is.matrix(x.new) & !is.data.frame(x.new) ){ #
        stop("The type of x.new is not correct. x.new must be a vector, a matrix or a data.frame, #
             where the 1st column is the original value of x and the 2nd is the new value of x.")#
    }else{#
        new.names <- data.frame(x.new[,-1])#
        rownames(new.names) <- x.new[,1]#
        x.new <- new.names#
    } #
    uniqueVals <- unique(x[!is.na(x)])#
    if(any(!uniqueVals %in% rownames(new.names)) ) {#
        x[x %in% uniqueVals[!uniqueVals %in% rownames(new.names)]] <- NA#
        msg <- paste0("These values: ", paste0(uniqueVals[!uniqueVals %in% rownames(new.names)], collapse = ", "), #
                             " are not the original values in x. These values are replaced by missing values.")#
        warning(msg)#
    }#
    if(is.na(labels)) labels <- paste0("X",1:ncol(new.names))#
    names(new.names) <- labels#
    D <- data.frame(new.names[x, ], stringsAsFactors = FALSE)#
    D#
}
NewData <- cleanData(QueenslandRaw, c("genderRaw","studentRaw","educationRaw"), "~/Desktop/R Packages/QueenslandMatch.xlsx")
Data <- QueenslandRaw#
varsClean <- c("genderRaw","studentRaw","educationRaw")#
matchFileName <- "~/Desktop/R Packages/QueenslandMatch.xlsx"#
header <- FALSE#
NewData <- cleanData(QueenslandRaw, c("genderRaw","studentRaw","educationRaw"), "~/Desktop/R Packages/QueenslandMatch.xlsx")
head(NewData)
i <- 1#
x <- Data[,varsClean[i]]#
x.new <- matchFile#
labels <- paste0(gsub("Raw","", varsClean[i]),1:(ncol(matchFile)-1))
f(is.vector(x.new)){#
        if(is.null(names(x.new))) stop("Each new value in x.new must be corresponding to a value in the original x.")#
        new.names <- as.matrix(x.new)#
        rownames(new.names) <- names(x.new) #
    }else if(!is.matrix(x.new) & !is.data.frame(x.new) ){ #
        stop("The type of x.new is not correct. x.new must be a vector, a matrix or a data.frame, #
             where the 1st column is the original value of x and the 2nd is the new value of x.")#
    }else{#
        new.names <- data.frame(x.new[,-1])#
        rownames(new.names) <- x.new[,1]#
        x.new <- new.names#
    }
uniqueVals <- unique(x[!is.na(x)])#
    if(any(!uniqueVals %in% rownames(new.names)) ) {#
        x[x %in% uniqueVals[!uniqueVals %in% rownames(new.names)]] <- NA#
        msg <- paste0("These values: ", paste0(uniqueVals[!uniqueVals %in% rownames(new.names)], collapse = ", "), #
                             " are not the original values in x. These values are replaced by missing values.")#
        warning(msg)#
    }
if(is.vector(x.new)){#
        if(is.null(names(x.new))) stop("Each new value in x.new must be corresponding to a value in the original x.")#
        new.names <- as.matrix(x.new)#
        rownames(new.names) <- names(x.new) #
    }else if(!is.matrix(x.new) & !is.data.frame(x.new) ){ #
        stop("The type of x.new is not correct. x.new must be a vector, a matrix or a data.frame, #
             where the 1st column is the original value of x and the 2nd is the new value of x.")#
    }else{#
        new.names <- data.frame(x.new[,-1])#
        rownames(new.names) <- x.new[,1]#
        x.new <- new.names#
    } #
    uniqueVals <- unique(x[!is.na(x)])#
    if(any(!uniqueVals %in% rownames(new.names)) ) {#
        x[x %in% uniqueVals[!uniqueVals %in% rownames(new.names)]] <- NA#
        msg <- paste0("These values: ", paste0(uniqueVals[!uniqueVals %in% rownames(new.names)], collapse = ", "), #
                             " are not the original values in x. These values are replaced by missing values.")#
        warning(msg)#
    }#
    if(is.na(labels)) labels <- paste0("X",1:ncol(new.names))#
    names(new.names) <- labels
x <- Data[,varsClean[i]]#
x.new <- matchFile#
labels <- paste0(gsub("Raw","", varsClean[i]),1:(ncol(matchFile)-1))
varsClean[i]
if(is.vector(x.new)){#
        if(is.null(names(x.new))) stop("Each new value in x.new must be corresponding to a value in the original x.")#
        new.names <- as.matrix(x.new)#
        rownames(new.names) <- names(x.new) #
    }else if(!is.matrix(x.new) & !is.data.frame(x.new) ){ #
        stop("The type of x.new is not correct. x.new must be a vector, a matrix or a data.frame, #
             where the 1st column is the original value of x and the 2nd is the new value of x.")#
    }else{#
        new.names <- data.frame(x.new[,-1])#
        rownames(new.names) <- x.new[,1]#
        x.new <- new.names#
    } #
    uniqueVals <- unique(x[!is.na(x)])
uniqueVals
if(any(!uniqueVals %in% rownames(new.names)) ) {#
        x[x %in% uniqueVals[!uniqueVals %in% rownames(new.names)]] <- NA#
        msg <- paste0("These values: ", paste0(uniqueVals[!uniqueVals %in% rownames(new.names)], collapse = ", "), #
                             " are not the original values in x. These values are replaced by missing values.")#
        warning(msg)#
    }
if(is.na(labels)) labels <- paste0("X",1:ncol(new.names))
new.names
labels
names(new.names) <- labels
D <- data.frame(new.names[x, ], stringsAsFactors = FALSE)
head(D)
recategorize <- function(x, x.new, labels = NA){#
#
    if(is.vector(x.new)){#
        if(is.null(names(x.new))) stop("Each new value in x.new must be corresponding to a value in the original x.")#
        new.names <- as.matrix(x.new)#
        rownames(new.names) <- names(x.new) #
    }else if(!is.matrix(x.new) & !is.data.frame(x.new) ){ #
        stop("The type of x.new is not correct. x.new must be a vector, a matrix or a data.frame, #
             where the 1st column is the original value of x and the 2nd is the new value of x.")#
    }else{#
        new.names <- data.frame(x.new[,-1])#
        rownames(new.names) <- x.new[,1]#
        x.new <- new.names#
    } #
    uniqueVals <- unique(x[!is.na(x)])#
    if(any(!uniqueVals %in% rownames(new.names)) ) {#
        x[x %in% uniqueVals[!uniqueVals %in% rownames(new.names)]] <- NA#
        msg <- paste0("These values: ", paste0(uniqueVals[!uniqueVals %in% rownames(new.names)], collapse = ", "), #
                             " are not the original values in x. These values are replaced by missing values.")#
        warning(msg)#
    }#
    if(is.na(labels)) labels <- paste0("X",1:ncol(new.names))#
    D <- data.frame(new.names[x, ], stringsAsFactors = FALSE)#
    names(new.names) <- labels#
    D#
}
cleanData <- function(Data, varsClean, matchFileName, ...){#
#
    if(!basename(matchFileName) %in% list.files(dirname(matchFileName))) { #
        stop(paste0(matchFileName, " does not exist."))#
    }else{ #
        if(!grep("\\.xlsx", matchFileName, ignore.case = TRUE)) stop("The matchFileName must have a xlsx extension.") #
        for(i in 1:length(varsClean)){#
            args <- match.call()#
            if(!"header" %in% names(args)) header = FALSE#
            matchFile <- xlsx::read.xlsx2(matchFileName, sheetName = varsClean[i], stringsAsFactors = FALSE, header = header)#
            Data <- data.frame(Data, recategorize(Data[,varsClean[i]], matchFile, labels = paste0(gsub("Raw","", varsClean[i]),1:(ncol(matchFile)-1))))#
        }#
    }#
    Data#
}
NewData <- cleanData(QueenslandRaw, c("genderRaw","studentRaw","educationRaw"), "~/Desktop/R Packages/QueenslandMatch.xlsx")
i <- 1#
x <- Data[,varsClean[i]]#
x.new <- matchFile#
labels <- paste0(gsub("Raw","", varsClean[i]),1:(ncol(matchFile)-1))
if(is.vector(x.new)){#
        if(is.null(names(x.new))) stop("Each new value in x.new must be corresponding to a value in the original x.")#
        new.names <- as.matrix(x.new)#
        rownames(new.names) <- names(x.new) #
    }else if(!is.matrix(x.new) & !is.data.frame(x.new) ){ #
        stop("The type of x.new is not correct. x.new must be a vector, a matrix or a data.frame, #
             where the 1st column is the original value of x and the 2nd is the new value of x.")#
    }else{#
        new.names <- data.frame(x.new[,-1])#
        rownames(new.names) <- x.new[,1]#
        x.new <- new.names#
    } #
    uniqueVals <- unique(x[!is.na(x)])#
    if(any(!uniqueVals %in% rownames(new.names)) ) {#
        x[x %in% uniqueVals[!uniqueVals %in% rownames(new.names)]] <- NA#
        msg <- paste0("These values: ", paste0(uniqueVals[!uniqueVals %in% rownames(new.names)], collapse = ", "), #
                             " are not the original values in x. These values are replaced by missing values.")#
        warning(msg)#
    }#
    if(is.na(labels)) labels <- paste0("X",1:ncol(new.names))#
    D <- data.frame(new.names[x, ], stringsAsFactors = FALSE)#
    names(new.names) <- labels
head(D)
labels
names(new.names)
recategorize <- function(x, x.new, labels = NA){#
#
    if(is.vector(x.new)){#
        if(is.null(names(x.new))) stop("Each new value in x.new must be corresponding to a value in the original x.")#
        new.names <- as.matrix(x.new)#
        rownames(new.names) <- names(x.new) #
    }else if(!is.matrix(x.new) & !is.data.frame(x.new) ){ #
        stop("The type of x.new is not correct. x.new must be a vector, a matrix or a data.frame, #
             where the 1st column is the original value of x and the 2nd is the new value of x.")#
    }else{#
        new.names <- data.frame(x.new[,-1])#
        rownames(new.names) <- x.new[,1]#
        x.new <- new.names#
    } #
    uniqueVals <- unique(x[!is.na(x)])#
    if(any(!uniqueVals %in% rownames(new.names)) ) {#
        x[x %in% uniqueVals[!uniqueVals %in% rownames(new.names)]] <- NA#
        msg <- paste0("These values: ", paste0(uniqueVals[!uniqueVals %in% rownames(new.names)], collapse = ", "), #
                             " are not the original values in x. These values are replaced by missing values.")#
        warning(msg)#
    }#
    if(is.na(labels)) labels <- paste0("X",1:ncol(new.names))#
    D <- data.frame(new.names[x, ], stringsAsFactors = FALSE)#
    names(D) <- labels#
    D#
}
cleanData <- function(Data, varsClean, matchFileName, ...){#
#
    if(!basename(matchFileName) %in% list.files(dirname(matchFileName))) { #
        stop(paste0(matchFileName, " does not exist."))#
    }else{ #
        if(!grep("\\.xlsx", matchFileName, ignore.case = TRUE)) stop("The matchFileName must have a xlsx extension.") #
        for(i in 1:length(varsClean)){#
            args <- match.call()#
            if(!"header" %in% names(args)) header = FALSE#
            matchFile <- xlsx::read.xlsx2(matchFileName, sheetName = varsClean[i], stringsAsFactors = FALSE, header = header)#
            Data <- data.frame(Data, recategorize(Data[,varsClean[i]], matchFile, labels = paste0(gsub("Raw","", varsClean[i]),1:(ncol(matchFile)-1))))#
        }#
    }#
    Data#
}
NewData <- cleanData(QueenslandRaw, c("genderRaw","studentRaw","educationRaw"), "~/Desktop/R Packages/QueenslandMatch.xlsx")
head(NewData)
i <- 2
Data <- QueenslandRaw#
varsClean <- c("genderRaw","studentRaw","educationRaw")#
matchFileName <- "~/Desktop/R Packages/QueenslandMatch.xlsx"#
header <- FALSE
header = FALSE
matchFile <- xlsx::read.xlsx2(matchFileName, sheetName = varsClean[i], stringsAsFactors = FALSE, header = header)
matchFile
x <- Data[,varsClean[i]]
head(x)
labels <- paste0(gsub("Raw","", varsClean[i]),1:(ncol(matchFile)-1))
labels
if(is.vector(x.new)){#
        if(is.null(names(x.new))) stop("Each new value in x.new must be corresponding to a value in the original x.")#
        new.names <- as.matrix(x.new)#
        rownames(new.names) <- names(x.new) #
    }else if(!is.matrix(x.new) & !is.data.frame(x.new) ){ #
        stop("The type of x.new is not correct. x.new must be a vector, a matrix or a data.frame, #
             where the 1st column is the original value of x and the 2nd is the new value of x.")#
    }else{#
        new.names <- data.frame(x.new[,-1])#
        rownames(new.names) <- x.new[,1]#
        x.new <- new.names#
    }
x.new
head(Data)
i <- 2#
x <- Data[,varsClean[i]]#
x.new <- matchFile#
labels <- paste0(gsub("Raw","", varsClean[i]),1:(ncol(matchFile)-1))
if(is.vector(x.new)){#
        if(is.null(names(x.new))) stop("Each new value in x.new must be corresponding to a value in the original x.")#
        new.names <- as.matrix(x.new)#
        rownames(new.names) <- names(x.new) #
    }else if(!is.matrix(x.new) & !is.data.frame(x.new) ){ #
        stop("The type of x.new is not correct. x.new must be a vector, a matrix or a data.frame, #
             where the 1st column is the original value of x and the 2nd is the new value of x.")#
    }else{#
        new.names <- data.frame(x.new[,-1])#
        rownames(new.names) <- x.new[,1]#
        x.new <- new.names#
    }
x.new
new.names
uniqueVals <- unique(x[!is.na(x)])
uniqueVals
any(!uniqueVals %in% rownames(new.names))
if(is.na(labels)) labels <- paste0("X",1:ncol(new.names))
is.na(labels)
recategorize <- function(x, x.new, labels = NA){#
#
    if(is.vector(x.new)){#
        if(is.null(names(x.new))) stop("Each new value in x.new must be corresponding to a value in the original x.")#
        new.names <- as.matrix(x.new)#
        rownames(new.names) <- names(x.new) #
    }else if(!is.matrix(x.new) & !is.data.frame(x.new) ){ #
        stop("The type of x.new is not correct. x.new must be a vector, a matrix or a data.frame, #
             where the 1st column is the original value of x and the 2nd is the new value of x.")#
    }else{#
        new.names <- data.frame(x.new[,-1])#
        rownames(new.names) <- x.new[,1]#
        x.new <- new.names#
    } #
    uniqueVals <- unique(x[!is.na(x)])#
    if(any(!uniqueVals %in% rownames(new.names)) ) {#
        x[x %in% uniqueVals[!uniqueVals %in% rownames(new.names)]] <- NA#
        msg <- paste0("These values: ", paste0(uniqueVals[!uniqueVals %in% rownames(new.names)], collapse = ", "), #
                             " are not the original values in x. These values are replaced by missing values.")#
        warning(msg)#
    }#
    if(any(is.na(labels))) labels <- paste0("X",1:ncol(new.names))#
    D <- data.frame(new.names[x, ], stringsAsFactors = FALSE)#
    names(D) <- labels#
    D#
}
cleanData <- function(Data, varsClean, matchFileName, ...){#
#
    if(!basename(matchFileName) %in% list.files(dirname(matchFileName))) { #
        stop(paste0(matchFileName, " does not exist."))#
    }else{ #
        if(!grep("\\.xlsx", matchFileName, ignore.case = TRUE)) stop("The matchFileName must have a xlsx extension.") #
        for(i in 1:length(varsClean)){#
            args <- match.call()#
            if(!"header" %in% names(args)) header = FALSE#
            matchFile <- xlsx::read.xlsx2(matchFileName, sheetName = varsClean[i], stringsAsFactors = FALSE, header = header)#
            Data <- data.frame(Data, recategorize(Data[,varsClean[i]], matchFile, labels = paste0(gsub("Raw","", varsClean[i]),1:(ncol(matchFile)-1))))#
        }#
    }#
    Data#
}
NewData <- cleanData(QueenslandRaw, c("genderRaw","studentRaw","educationRaw"), "~/Desktop/R Packages/QueenslandMatch.xlsx")
head(NewData)
recategorize(c(1,4,2,3,NA), data.frame(c(1,2,3), c(1,1,0), c(1, -1, 0)) )
recategorize <- function(x, x.new, labels = NA){#
#
    if(is.vector(x.new)){#
        if(is.null(names(x.new))) stop("Each new value in x.new must be corresponding to a value in the original x.")#
        new.names <- as.matrix(x.new)#
        rownames(new.names) <- names(x.new) #
    }else if(!is.matrix(x.new) & !is.data.frame(x.new) ){ #
        stop("The type of x.new is not correct. x.new must be a vector, a matrix or a data.frame, #
             where the 1st column is the original value of x and the 2nd is the new value of x.")#
    }else{#
        new.names <- data.frame(x.new[,-1])#
        rownames(new.names) <- x.new[,1]#
        x.new <- new.names#
    } #
    uniqueVals <- unique(x[!is.na(x)])#
    if(any(!uniqueVals %in% rownames(new.names)) ) {#
        x[x %in% uniqueVals[!uniqueVals %in% rownames(new.names)]] <- NA#
        msg <- paste0("A list of unique values of x does not contain ",paste0(uniqueVals[!uniqueVals %in% rownames(new.names)], collapse = ", "), #
                             ". These values are replaced by missing values.")#
        warning(msg)#
    }#
    if(any(is.na(labels))) labels <- paste0("X",1:ncol(new.names))#
    D <- data.frame(new.names[x, ], stringsAsFactors = FALSE)#
    names(D) <- labels#
    D#
}
recategorize(c(1,4,2,5,3,NA), data.frame(c(1,2,3), c(1,1,0), c(1, -1, 0)) )
recategorize(c(1,2,3), cbind(c(1,2,3), c(1,1,0)))
recategorize(c(1,2,3), cbind(c(1,2,3), c(1,1,0), c(1,-1,0)))
recategorize(c(1,2,3), c("1" = 1, "2" = 1, "3" = 0))
recategorize(c(1,2,5,3,4), c("1" = 1, "2" = 1, "3" = 0))
write.csv()
?write.csv
?ddply
library(devtools)
getwd()
library(roxygen2)
install()
?rename
library(pplpredict)
?rename
?cleanData
document()
install()
?rename
sys.time()
Sys.time()
cat("Start the imputation for ", paste0(groupNames[[i]],collapse = "|"), "at ", startTime)
startTime <- Sys.time()#
    cat("Start the imputation for the group:", paste0(groupNames[[i]],collapse = "|"), "at ", startTime)
cat("Finish imputing for the group:", paste0(groupNames[[i]],collapse = "|"), "at", as.character(Sys.time()), ".The total running time is", as.character(Sys.time() - startTime),"mins")
